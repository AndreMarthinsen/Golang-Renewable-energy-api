package fsutils

import (
	"Assignment2/util"
	"fmt"
	"reflect"
	"testing"
	"unicode/utf8"
)

// Types for testing
type MockType float32

type MockData struct {
	First  string   `firestore:"first,omitempty"`
	Second []int    `firestore:"second,omitempty"`
	Third  MockType `firestore:"third,omitempty"`
}

const serviceAccountPath = "../cmd/sha.json"
const testCollection = "fsutil_test"

// TestInitializeFirestore checks if initializing is successful
func TestInitializeFirestore(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()

	if err != nil {
		t.Error("could not initialize")
	}
}

// TestAddDocument checks if document can be added to collection
func TestAddDocument(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()
	if err != nil {
		t.Error("could not initialize")
	}

	testData := map[string]interface{}{
		"first":  "first_value",
		"second": "second_value",
		"third":  "third_value",
	}

	id, err := AddDocument(&config, testCollection, testData)
	if err != nil {
		t.Error("could not create document")
	}
	// Assumes that autogenerated ID is always 20 chars:
	if utf8.RuneCountInString(id) != 20 {
		t.Error("unable to return valid id")
	}
	// Delete created document:
	err = DeleteDocument(&config, testCollection, id)
	if err != nil {
		t.Error("could not delete document")
	}

}

// TestAddDocumentById checks if document can be added to collection
func TestAddDocumentById(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()
	if err != nil {
		t.Error("could not initialize")
	}

	testData := MockData{
		First:  "testing",
		Second: []int{1, 2, 3},
		Third:  0.456,
	}

	fmt.Println("Trying to add: ", testData)
	id := "myTestDoc"
	err = AddDocumentById(&config, testCollection, id, testData)
	if err != nil {
		t.Error("could not create document")
	}

	err = DeleteDocument(&config, testCollection, id)
	if err != nil {
		t.Error("could not delete document")
	}

}

// TestDeleteDocument creates a new document and then deletes it
func TestDeleteDocument(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()
	if err != nil {
		t.Error("could not initialize")
	}

	testData := map[string]interface{}{
		"aaa": 1,
	}

	newDoc, _ := AddDocument(&config, testCollection, testData)

	err = DeleteDocument(&config, testCollection, newDoc)
	if err != nil {
		t.Error("could not delete document")
	}
}

// TestDeleteNonExistingDocument tries to delete a document that does not exist
func TestDeleteNonExistingDocument(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()
	if err != nil {
		t.Error("could not initialize")
	}

	err = DeleteDocument(&config, testCollection, "non-existingId")
	if err != nil {
		t.Error("could not delete document")
	}

}

// TestReadDocument reads document with known content
func TestReadDocument(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()
	if err != nil {
		t.Error("could not initialize")
	}
	testData := map[string]interface{}{
		"a":   1,
		"bb":  "two",
		"ccc": 3.0,
	}

	newDoc, err := AddDocument(&config, testCollection, testData)
	if err != nil {
		t.Error("unable to create new document")
	}
	// read back known document:
	content, err := ReadDocument(&config, testCollection, newDoc)
	if err != nil {
		t.Error("unable to read document")
	}

	out := fmt.Sprint(testData)
	in := fmt.Sprint(content)
	if out != in {
		t.Error("could not get back equal data")
	}
	// delete created document:
	err = DeleteDocument(&config, testCollection, newDoc)
	if err != nil {
		t.Error("could not delete document")
	}
}

// TestReadDocumentGeneral creates a new document from MockData struct and
// then reads it back into a struct of the same type
func TestReadDocumentGeneral(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()
	if err != nil {
		t.Error("could not initialize")
	}

	testData := MockData{
		First:  "testing",
		Second: []int{1, 2, 3},
		Third:  0.456,
	}

	testReadData := MockData{}

	newDoc, err := AddDocument(&config, testCollection, testData)
	if err != nil {
		t.Error("unable to create new document")
	}
	// read back known document:
	err = ReadDocumentGeneral(&config, testCollection, newDoc, &testReadData)
	if err != nil {
		t.Error("unable to read document")
	}

	fmt.Println("data: ", testReadData)
	if !reflect.DeepEqual(testData, testReadData) {
		fmt.Println("added data: ", testData)
		fmt.Println("returned data: ", testReadData)
		t.Error("could not get same struct back")
	}

	err = DeleteDocument(&config, testCollection, newDoc)
	if err != nil {
		t.Error("could not delete document")
	}
}

// TestReadDocumentNonexisting tries to read a document with invalid id
func TestReadDocumentNonexisting(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()
	if err != nil {
		t.Error("could not initialize")
	}
	// try reading non-existing document:
	_, err = ReadDocument(&config, testCollection, "invalid_name")

	if err == nil {
		t.Error("reading non-existing document returned no error")
	}

}

// TestCountDocuments counts all documents in a specified collection;
// a test collection with 5 documents is created, counted and deleted
func TestCountDocuments(t *testing.T) {
	var config util.Config
	err := NewFirestoreContext(&config, serviceAccountPath)
	defer func() {
		err := Close(&config)
		if err != nil {
			t.Error(err)
		}
	}()
	if err != nil {
		t.Error("could not initialize")
	}
	// Create new collection with 5 docs:
	newCollection := testCollection
	var ids []string
	for i := 0; i < 5; i++ {
		id, _ := AddDocument(&config, newCollection, map[string]interface{}{"a": i + 1})
		ids = append(ids, id)
	}

	count, err := CountDocuments(&config, newCollection)
	if err != nil {
		t.Error("unable to count")
	}

	if count != 5 {
		t.Error("wrong number of docs")
	}

	// delete newly created docs:
	for _, id := range ids {
		err = DeleteDocument(&config, newCollection, id)
		if err != nil {
			t.Error("unable to delete document")
		}
	}
	// count again; check if all are deleted:
	count, err = CountDocuments(&config, newCollection)
	if err != nil {
		t.Error("unable to count")
	}
	if count != 0 {
		t.Error("wrong number of docs")
	}
}
