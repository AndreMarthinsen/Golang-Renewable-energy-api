package testing

import (
	"Assignment2/firebase"
	"fmt"
	"reflect"
	"testing"
	"unicode/utf8"
)

// Types for testing
type MockType float32

type MockData struct {
	First  string   `firestore:"first,omitempty"`
	Second []int    `firestore:"second,omitempty"`
	Third  MockType `firestore:"third,omitempty"`
}

const serviceAccountPath = "./demo-service-account.json"
const testCollection = "mess"

// TestInitializeFirestore checks if initializing is successful
func TestInitializeFirestore(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}
}

// TestAddDocument checks if document can be added to collection
func TestAddDocument(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}

	testData := map[string]interface{}{
		"first":  "first_value",
		"second": "second_value",
		"third":  "third_value",
	}

	id, err := firebase.AddDocument(&config, testCollection, testData)
	if err != nil {
		t.Error("could not create document")
	}
	// Assumes that autogenerated ID is always 20 chars:
	if utf8.RuneCountInString(id) != 20 {
		t.Error("unable to return valid id")
	}

} // TestAddDocument checks if document can be added to collection
func TestAddDocumentById(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}

	testData := MockData{
		First:  "testing",
		Second: []int{1, 2, 3},
		Third:  0.456,
	}

	fmt.Println("Trying to add: ", testData)
	id := "myTestDoc"
	err = firebase.AddDocumentById(&config, testCollection, id, testData)
	if err != nil {
		t.Error("could not create document")
	}
}

// TestDeleteDocument creates a new document and then deletes it after a delay
func TestDeleteDocument(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}

	testData := map[string]interface{}{
		"aaa": 1,
	}

	newDoc, _ := firebase.AddDocument(&config, testCollection, testData)

	err = firebase.DeleteDocument(&config, testCollection, newDoc)
	if err != nil {
		t.Error("could not delete document")
	}
}

// TestDeleteNonExistingDocument tries to delete a document that does not exist
func TestDeleteNonExistingDocument(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}

	err = firebase.DeleteDocument(&config, testCollection, "non-existingId")
	if err != nil {
		t.Error("could not delete document")
	}

}

// TestReadDocument reads document with known content
func TestReadDocument(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}
	testData := map[string]interface{}{
		"a":   1,
		"bb":  "two",
		"ccc": 3.0,
	}

	newDoc, err := firebase.AddDocument(&config, testCollection, testData)
	if err != nil {
		t.Error("unable to create new document")
	}
	// read back know document:
	content, err := firebase.ReadDocument(&config, testCollection, newDoc)
	if err != nil {
		t.Error("unable to read document")
	}
	// TODO safer equality testing?
	out := fmt.Sprint(testData)
	in := fmt.Sprint(content)
	if out != in {
		t.Error("could not get back equal data")
	}
}

// TestReadDocumentGeneral creates a new document from MockData struct and
// then reads it back into a struct of the same type
func TestReadDocumentGeneral(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}

	testData := MockData{
		First:  "testing",
		Second: []int{1, 2, 3},
		Third:  0.456,
	}

	testReadData := MockData{}

	newDoc, err := firebase.AddDocument(&config, testCollection, testData)
	if err != nil {
		t.Error("unable to create new document")
	}
	// read back known document:
	err = firebase.ReadDocumentGeneral(&config, testCollection, newDoc, &testReadData)
	if err != nil {
		t.Error("unable to read document")
	}

	fmt.Println("data: ", testReadData)
	if !reflect.DeepEqual(testData, testReadData) {
		fmt.Println("added data: ", testData)
		fmt.Println("returned data: ", testReadData)
		t.Error("could not get same struct back")
	}
}

// TestReadDocumentNonexisting tries to read a document with invalid id
func TestReadDocumentNonexisting(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}
	// read back known document:
	_, err = firebase.ReadDocument(&config, testCollection, "invalid_name")

	if err != nil {
		t.Error("unable to read document")
	}

}

// TestCountDocuments
func TestCountDocuments(t *testing.T) {
	var config firebase.Config
	err := firebase.NewFirestoreContext(&config, serviceAccountPath)
	defer firebase.Close(&config)
	if err != nil {
		t.Error("could not initialize")
	}
	// Create new collection with 5 docs:
	newCollection := "test123"
	var ids []string
	for i := 0; i < 5; i++ {
		id, _ := firebase.AddDocument(&config, newCollection, map[string]interface{}{"a": i + 1})
		ids = append(ids, id)
	}

	count, err := firebase.CountDocuments(&config, newCollection)
	if err != nil {
		t.Error("unable to count")
	}
	fmt.Println("Number of docs: ", count)
	if count != 5 {
		t.Error("wrong number of docs")
	}

	// delete newly created docs:
	for _, id := range ids {
		err = firebase.DeleteDocument(&config, newCollection, id)
		if err != nil {
			t.Error("unable to delete")
		}
	}
	// count again; check if all are deleted:
	count, err = firebase.CountDocuments(&config, newCollection)
	if err != nil {
		t.Error("unable to count")
	}
	if count != 0 {
		t.Error("wrong number of docs")
	}

}
